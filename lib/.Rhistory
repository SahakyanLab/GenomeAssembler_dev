}
genome.construction <- function(path){
# initialise vector to save genome path
genome <- character()
# reconstruct genome path for a given string
len <- nchar(path[1])
genome <- c(substring(path[1], first = 1:len, last = 1:len),
substring(path[2:length(path)], first = len, last = len))
genome <- paste(genome, collapse = "")
return(genome)
}
eulerian.path <- function(newList){
# re-define objects from previous functions' output
dict           <- newList[[1]]
suffix         <- newList[[2]]
balanced.count <- newList[[3]]
# create copies for use in the pathway explorations
dict.copy <- dict
# obtain all possible starting points of the genome
start.point <- list()
for(i in 1:length(balanced.count)){
if(balanced.count[[i]]==-1){
start.point <- c(start.point, names(balanced.count)[i])
}
}
# initialise list of reconstructed genome paths with the highest score
pathways <- list(); pathways
# initialise text progress bar
print("Traversing all paths in the rooted tree...", quote = F)
pb <- txtProgressBar(min = 1, max = length(start.point)+1, style = 3)
start.point.index = 1
while(start.point.index<=length(start.point)){
# initialise list to store number of branching points per step
branch.point <- list()
# initialise list to save the reconstructed genome path
all.paths <- list()
# initialise current path with starting point
path <- start.point[[start.point.index]]
main.index = 1
continue = TRUE
while(continue){
if(main.index==1){
### iteration one ###
i = 1
while(TRUE){
last.item <- tail(path, n = 1)
all.items <- dict[last.item][[1]]
# store the number of branching points per step
if(length(all.items)>0){
branch.point[[i]] <- seq(1,length(all.items),1)
}
# always traverse the tree along the left-most path
new.item  <- all.items[1]
if(length(new.item)>0){
path <- c(path, new.item)
if(length(dict[last.item][[1]])>1){
dict[last.item][[1]] <- dict[last.item][[1]][-which(new.item==dict[last.item][[1]])]
} else {
dict[last.item] <- NULL
}
} else {
# save reconstructed genome path into list
all.paths <- c(all.paths, genome.construction(path))
# pop reverse path from the list
# until latest branching points first index
for(l in length(branch.point):1){
if(length(branch.point[[l]])>1){
branch.point[[l]] <- branch.point[[l]][-branch.point[[l]][1]]
break
} else {
branch.point[[l]] <- NULL
}
}
main.index = main.index+1
break
}
i = i+1
}
} else {
### iteration two and onward ###
while(length(branch.point)>=0){
# reset dict
dict <- dict.copy
# re-initialise current path with starting point
path <- start.point[[start.point.index]]
i = 1
while(TRUE){
last.item <- tail(path, n = 1)
all.items <- dict[last.item][[1]]
if(i<=length(branch.point)){
# always traverse the tree along the left-most path
new.item  <- all.items[branch.point[[i]][1]]
} else {
new.item  <- all.items[1]
# store the number of branching points per step
if(length(all.items)>0){
branch.point[[i]] <- seq(1,length(all.items),1)
}
}
if(length(new.item)>0){
path <- c(path, new.item)
if(length(dict[last.item][[1]])>1){
dict[last.item][[1]] <- dict[last.item][[1]][-which(new.item==dict[last.item][[1]])]
} else {
dict[last.item] <- NULL
}
} else {
# save reconstructed genome path into list
all.paths <- c(all.paths, genome.construction(path))
# pop reverse path from the list
# until latest branching points first index
for(l in length(branch.point):1){
if(length(branch.point[[l]])>1){
branch.point[[l]] <- branch.point[[l]][-branch.point[[l]][1]]
break
} else {
branch.point[[l]] <- NULL
}
}
break
}
i = i+1
}
# if no more branches to traverse with current starting point
# save all generated strings from current starting point
# to another list; restart everything with
# different starting point
if(length(branch.point)==0){
pathways <- c(pathways, all.paths)
start.point.index = start.point.index+1
continue = FALSE
break
}
}
}
}
setTxtProgressBar(pb, start.point.index)
}
close(pb)
print("Eulerian paths constructed!", quote = FALSE)
return(pathways)
}
alignment.scoring <- function(path, randSeq, NCPU = NCPU){
packages <- function(x){
for(i in x){
if(!require(i, character.only = TRUE)){
install.packages(i, dependencies = TRUE)
library(i, character.only = TRUE)
} else {
library(i, character.only = TRUE)
}
}
}
suppressMessages(packages(c("Biostrings", "doParallel",
"foreach", "itertools")))
# set-up cluster for parallel computation
cl <- makeCluster(NCPU)
registerDoParallel(cl)
# remove strings which contain NAs
if(length(grep("NA", path))>0){
path <- path[-grep("NA", path)]
}
rand.seq.combined <- paste(randSeq, collapse = "")
ref.seq <- DNAString(rand.seq.combined)
# obtain all higher-order k-mers in the reference genome
k = 25
kmer.count <- function(seq, k){
sequence <- unlist(strsplit(as.character(seq), split = ""))
end      <- length(sequence)-k+1
kmer     <- substring(paste(sequence, collapse = ""),
first = 1:end, last = (1:end)+k-1)
kmer     <- unlist(kmer)
return(kmer)
}
kmers.ref <- kmer.count(as.character(ref.seq), k)
# calculate alignment scores of all paths and return only the sequence with max score
print("Calculating alignment scores...", quote = F)
alignment.runs <- foreach(chunk = isplitVector(1:length(path),
chunks = ceiling(length(path)/NCPU)),
.packages = c("foreach", "Biostrings"),
.combine = "rbind")%dopar%{
foreach(i = chunk, .combine = "rbind", .inorder = FALSE)%do%{
seq.new <- DNAString(path[[i]])
mat     <- nucleotideSubstitutionMatrix(match = 1,
mismatch = -3, baseOnly = TRUE)
# global pairwise alignment
globalAlign  <-
pairwiseAlignment(ref.seq, seq.new,
type = "global", substitutionMatrix = mat,
gapOpening = 5, gapExtension = 2, scoreOnly = TRUE)
# local pairwise alignment
localAlign   <-
pairwiseAlignment(ref.seq, seq.new,
type = "local", substitutionMatrix = mat,
gapOpening = 5, gapExtension = 2, scoreOnly = TRUE)
# global-local pairwise alignment
global.localAlign <-
pairwiseAlignment(ref.seq, seq.new,
type = "global-local", substitutionMatrix = mat,
gapOpening = 5, gapExtension = 2, scoreOnly = TRUE)
# local-global pairwise alignment
local.globalAlign <-
pairwiseAlignment(ref.seq, seq.new,
type = "local-global", substitutionMatrix = mat,
gapOpening = 5, gapExtension = 2, scoreOnly = TRUE)
# higher order k-meric signature counting
kmers.new  <- kmer.count(as.character(seq.new), k)
kmer.score <- ceiling(length(match(which(!is.na(match(kmers.ref, kmers.new))==TRUE),
kmers.new))/length(kmers.ref)*100)
# levenshtein distance; the lower the levenshtein score, the better;
# hence need to subtract from final score
ls.score <- as.numeric(stringDist(c(as.character(ref.seq), as.character(seq.new)),
method = "levenshtein"))
finalAlign <- globalAlign+localAlign+global.localAlign+local.globalAlign+kmer.score-ls.score
out.put <- data.frame(score = finalAlign,
seq = as.character(seq.new))
return(out.put)
}
}
stopCluster(cl)
print("Alignment scores calculated!", quote = F)
return(list(alignment.runs$seq[match(max(alignment.runs$score), alignment.runs$score)],
alignment.runs$score))
}
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
randSeq <- ReadsGenerator(len = 1000, G.cont = 0.3, C.cont = 0.3,
A.cont = 0.2, NCPU = 2, k.mer = 2, prob.type = "non-uniform")
# length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[3]])
# length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
output  <- eulerian.path(get.balance.count(
debrujin.graph.from.kmers(kmer.composition(k = 5))))
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))
# length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 6)))[[3]])
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 6)))
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 7)))
output  <- eulerian.path(get.balance.count(
debrujin.graph.from.kmers(kmer.composition(k = 7))))
output  <- eulerian.path(get.balance.count(
debrujin.graph.from.kmers(kmer.composition(k = 9))))
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[3]]
# length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[3]])
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[3]]
setwd("/Volumes/Paddy_Backup/ProjectBoard_Patrick/02-Proof_of_principle/scripts/")
source("../lib/BreakageProbScoring.R")
source("../lib/DeBruijnGraph_Assembler.R")
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))
output  <- eulerian.path(get.balance.count(
debrujin.graph.from.kmers(kmer.composition(k = 9))))
output  <- eulerian.path(get.balance.count(
debrujin.graph.from.kmers(kmer.composition(k = 8))))
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 8)))
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 8)))[[1]]
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 8)))[[1]])
length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]])
get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
x
x[[1]]
x[1]
lenght(x[1])
length(x[1])
length(x[[1]])
test <- list()
test <- list()
for(i in 1:length(x)){
if(x[[i]]>2){
test <- c(test, x[[i]])
}
}
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
test
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
test
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 8)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])==2){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])==3){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])==4){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 7)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])==4){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])==3){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])==2){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 8)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 7)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 6)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 4)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
out <- string.reconstruction(len = 2000, G.cont = 0.3, C.cont = 0.3, A.cont = 0.2,
k = 9, NCPU = 2, prob.type = "non-uniform")
randSeq <- ReadsGenerator(len = 2000, G.cont = 0.3, C.cont = 0.3, A.cont = 0.2,
k.mer = 2, NCPU = 2, prob.type = "non-uniform")
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
length(test)
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 8)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>3){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
randSeq <- ReadsGenerator(len = 3000, G.cont = 0.3, C.cont = 0.3, A.cont = 0.2,
k.mer = 2, NCPU = 2, prob.type = "non-uniform")
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
length(test)
randSeq <- ReadsGenerator(len = 10000, G.cont = 0.3, C.cont = 0.3, A.cont = 0.2,
k.mer = 2, NCPU = 2, prob.type = "non-uniform")
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
length(test)
setwd("/Volumes/Paddy_Backup/ProjectBoard_Patrick/02-Proof_of_principle/scripts/")
source("../lib/BreakageProbScoring.R")
source("../lib/ReadsGenerator.R")
source("../lib/DeBruijnGraph_Assembler.R")
randSeq <- ReadsGenerator(len = 1000, G.cont = 0.3, C.cont = 0.3, A.cont = 0.2,
k.mer = 2, NCPU = 2, prob.type = "non-uniform")
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
randSeq <- ReadsGenerator(len = 5000, G.cont = 0.3, C.cont = 0.3, A.cont = 0.2,
k.mer = 2, NCPU = 2, prob.type = "non-uniform")
x <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[1]]
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>1){
test <- c(test, x[[i]])
}
}
length(test)
test <- list()
for(i in 1:length(x)){
if(length(x[[i]])>2){
test <- c(test, x[[i]])
}
}
length(test)
# length(get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 5)))[[3]])
y <- get.balance.count(debrujin.graph.from.kmers(kmer.composition(k = 9)))[[3]]
y
min(y)
unlist(y)
max(unlist(y))
min(unlist(y))
which(min(unlist(y)==-2))
which(min(unlist(y)))
which(unlist(y)==-2)
paste(randSeq[[1]], collapse = "")
